import * as core from '@actions/core';
import { readFile } from 'fs/promises';
import { JSDOM } from 'jsdom';
import { homedir } from 'os';
import { resolve } from 'path';
import { parse } from 'zipson';
import { MetadataDetail } from '../src/constants/marketplace';

export const readIssueBody = async (): Promise<HTMLDetailsElement[]> => {
    const issue = await readFile(resolve(homedir(), 'issue.json'), 'utf-8');
    const data = JSON.parse(issue);
    let issueBody = data.body as string;

    if (issueBody.includes('https://github.com/user-attachments/files/')) {
        const bodyURL = issueBody.match(/\(https:\/\/github.com\/user-attachments\/files\/.+\)/)?.at(0);
        if (bodyURL === undefined) {
            core.setOutput(
                'message',
                'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
            );
            throw new Error('The file link must be valid.');
        }
        issueBody = await (await fetch(bodyURL.substring(1, bodyURL.length - 1))).text();
    }

    const dom = new JSDOM(issueBody);
    return Array.from(dom.window.document.querySelectorAll('details[repo="rmp-gallery"]'));
};

export const parseDetailsEl = (detailsEls: HTMLDetailsElement[]) => {
    if (detailsEls.length !== 2) {
        core.setOutput(
            'message',
            'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
        );
        throw new Error('There must be only two details elements.');
    }
    const metadataDetailEl = detailsEls.find(el => el.getAttribute('type') === 'metadata');
    if (!metadataDetailEl) {
        core.setOutput(
            'message',
            'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
        );
        throw new Error('Detail element of metadata is required.');
    }
    const metadataDetail = JSON.parse(metadataDetailEl.textContent!.trim()) as MetadataDetail;
    const id = metadataDetailEl.getAttribute('id');
    if (!id) {
        core.setOutput(
            'message',
            'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
        );
        throw new Error('Id is required.');
    }

    const paramDetailEl = detailsEls.find(el => el.getAttribute('type') === 'styles');
    if (!paramDetailEl) {
        core.setOutput(
            'message',
            'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
        );
        throw new Error('Detail element of real world data is required.');
    }
    const compressMethod = paramDetailEl.getAttribute('compress');
    if (compressMethod !== 'zipson' && compressMethod !== 'none') {
        core.setOutput(
            'message',
            'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
        );
        throw new Error('Data must be compressed by zipson or be raw.');
    }
    if (paramDetailEl.textContent === null) {
        core.setOutput(
            'message',
            'Remember to follow the gallery guidelines to upload the file generated by the gallery or paste the text into issue content.'
        );
        throw new Error('textContent must contains data.');
    }

    const decompress: (s: string) => any = compressMethod === 'zipson' ? parse : (s: string) => JSON.parse(s);
    // trim to make a valid zipson data
    const param = decompress(paramDetailEl.textContent.trim());

    return { metadataDetail, param, id };
};
